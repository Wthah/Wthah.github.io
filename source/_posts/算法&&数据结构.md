---
title: 算法&&数据结构
date: 2022/3/8 11:21:25
tags:
  - 算法
  - 数据结构
categories:
  - 算法
  - 数据结构
cover: /img/algorithm/algorithm.jpg
---

# 1.算法&&数据结构

## 1. 概述

### 1. 数据结构的分类

#### 1. 逻辑结构：

> - `逻辑结构`
> - `线性结构`
> - `树形结构`
> - `图形结构`

#### 2. 算法分析

> - `时间`
> - `空间`

#### 3. 时间复杂度分析：

- `传统的用计算机计时器分析(不太理想)`

  ```java
  Long begin = System.currentTimeMills();
  Long end = System.cuttentTimeMills();
  Long time = end - begin;
  ```

- `渐进增长`

  > 1. 算法常数操作忽略不计
  > 2. 最高次项相乘常熟忽略
  > 3. 只保留最高项

- `常见大O项`

  > 1. 线性阶
  > 2. 平方阶
  > 3. 对数阶
  > 4. 立方阶
  > 5. 常数阶

- `函数调用的时间复杂度`

  > 1. O(1)(输出)
  >
  >    ```java
  >    private static void show(int i) { System.out.println(i); }
  >    ```
  >
  >    
  >
  > 2. O(n)(循环)
  >
  >    ```java
  >    public static void main(String[] args) { 
  >        int n=100; 
  >        for (int i = 0; i < n; i++) 
  >        { 
  >            show(i); 
  >        } 
  >    }
  >    ```
  >
  > 3. O(n^2)
  >
  >    ```java
  >    public static void main(String[] args){
  >    	int n = 100;
  >    	for(int i =0; i<n; i++){
  >    		show(i);
  >    	}
  >    }
  >                               
  >    private static void show(int i){
  >        for(int j=0; j<i; i++){
  >            System.out.println(i);
  >        }
  >    }
  >    ```

- `最坏情况，最好情况，平均情况`

#### 4. 空间复杂度分析

- `基本数据类型内存占用情况`

  > 整数类型：byte（1）、short（2）、int（4）、long（8）
  >
  > 浮点数：float（4）、double（8）
  >
  > 布尔：boolean（1）
  >
  > 字符：char（2）

- `一个引用（8）`

- `创建一个对象（16）`

- `自动补全成8字节`

## 2. 简单排序

> 稳定性含义：A和B相等，A在B的前边，排序之后A仍然在B的前边

### 1. Comparable接口

```java
@Data
public class Student implements Comparable<Student>{
    
    private String name;
    private int age;
    
    @Override
    public int compareTo(Student o){
        return this.getAge()-o.getAge();
    }
}
```

### 2. 冒泡排序（稳定）

```java
public class Bubble{
    public static void sort(Comparable[] a){
        for(int i=0; i<a.length; i++){
            for(int j=0; j<a.length-i; j++){
                if(a[j].compareTo(a[j+1])>0){
                    Comparable t = a[j];
                    a[j] = a[j+1];
                    a[j+1] = t;
                }
            }
        }
    }
}

// 时间复杂度O(n^2)
// 最佳情况应该是(N*(N-1))/2 比较+ (N*(N-1))/2 交换
// 平均情况应该是(N*(N-1))/2 比较+ (N*(N-1))/4 交换
// 最佳应该是(N*(N-1))/2 比较
// 改进
public class Bubble{
    public static void sort(Comparable[] a){
        for(int i=0; i<a.length; i++){
            boolean flag = true;
            for(int j=0; j<a.length-i; j++){
                if(a[j].compareTo(a[j+1])>0){
                    Comparable t = a[j];
                    a[j] = a[j+1];
                    a[j+1] = t;
                    num++;
                    flag = false;
                }
            }
            if(flag == true){
                break;
            }
        }
    }
}
```

### 3. 选择排序（不稳定）

```java
public class Selection{
    public boolean greater(Comparable a, Comparable b){
        return a.compareTo(b) > 0
    }
    
    public void exch(Comparable[] a,int i,int j){
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    public void sort(Comparable[] a){
        for(int i=0;i<=a.length-2;i++){
            int minIndex = i;
            for(int j=i+1;j<a.length;j++){
                if(greater(a[minIndex],a[j])){
                    minIndex = j;
                }
            }
            exch(a,i,minIndex);
        }
    }
}

// 数据比较((N-1+1)*(N-1))/2
// 数据交换(N-1)
// 最佳((N-1+1)*(N-1))/2

```

### 4. 插入排序（稳定）

![image-20220310140620540](/img/algorithm/image-20220310140620540.png)

![image-20220310140804418](/img/algorithm/image-20220310140804418.png)

```java
public class Insertion{
    public boolean greater(Comparable a,Comparable b){
        return a.compareTo(b)>0;
    }
    
    public void exch(Comparable[] a,int i,int j){
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    public static void sort(Comparable[] a){
        for(int i=1;i<a.length;i++){
            for(int j=i;j>0;j--){
                if(a[j]>a[j-1]){
                    exch(a,j,j-1);
                }
                else{
                    break;
                }
            }
        }
    }
}

//最差情况：比较n*(n-1)/2 交换n*(n-1)/2
//最好和冒泡类似，一次就不管了
//插入排序不适合数据量比较大或重复次数较多的时候
```

### 5. 希尔排序（插入排序的升级）

> 减少交换的次数，增长量h，没有固定值

### 6. 归并排序（稳定）

![image-20220310144535529](/img/algorithm/image-20220310144535529.png)

```java
public class Merge{
    private static Comparable[] assist;
    
    public static void sort(Comparable[] a){
        assist = new Comparable[a.length];
        int lo = 0;
        int hi = a.length-1
        sort(a, lo, hi)
    }
    
    public void sort(Comparable[] a,int lo,int hi){
        if(hi <= lo){
            return;
        }
        
        int mid = lo+(lo+hi)/2;
        sort(a,lo,mid);
        sort(a,mid+1,hi);
        merge(a,lo,mid,hi);
    }
    
    public void merge(Comparable[] a,int lo,int mid,int hi){
        int i = lo;
        int p1 = lo;
        int p2 = mid+1;
        
        while(p1<=mid&&p2<=hi){
            if(a[p1]>a[p2]){
                assist[i++] = a[p2++];
            }
            else{
                assist[i++] = a[p1++];
            }
        }
        
        while(p1<=mid){
            assist[i++] = a[p1++];
        }
        
        while(p2<=hi){
            assist[i++] = a[p2++];
        }
        
        for(int i=0;i<hi;i++){
            a[index] = assist[index];
        }
    }
}

// 每层数组长度是2^(log2n-k) k是层数 此层的数组个数有2^k个 每层的时间复杂度也就是n
// 不适合大数据，容易造成堆栈溢出，使用了递归
```

### 7. 快速排序

![image-20220310155322123](/img/algorithm/image-20220310155322123.png)

```java
public class Quick{
    public static void sort(Comparable[] a){
        int lo = 0;
        int hi = a.length;
        sort(a,lo,hi);
    }
    
    public void sort(Comparable[] a, int lo,int hi){
        if(hi<=lo){
            return;
        }
        
        int partition = partion(a,lo,hi);
        sort(a,lo,partition-1);
        sort(a,partition+1,hi);
        
    }
    
    public int partition(Comparable[] a,int lo, int hi){
        Comparable key = a[lo];
        int left = lo;
        int right = hi;
        while(true){
            while(key<a[right--]){
                if(right<=left){
                    break;
                }
            }
            
            while(key>a[++left]){
                if(right<=left){
                    break;
                }
            }
            
            if(left>=right){
                break;
            }
            
            else{
                exch(a[left],a[right]);
            }
        }
        
        exch(a,lo,right);
        return right;
    }
}

//最优情况，每次都分一般
//最差，已经分好了
//一般是最快的，属于是冒泡升级版，冒泡效率最低
```

### 8.基数排序

> 通过位来比较，先个位在十位，逐渐往上。
>
> **第一种方式：求出最大值，将最大值不断/10，求最大值的位数，最大值的位数就是这n个元素的最长位数**
>
> **第二种方式：遍历n个元素，对于某一个元素和p比较，如果比p大，就扩大p的值，同时位数+1**
>
> **生成十个桶（十个数组）**
>
> **我们需要统计一下，当前这一轮排序，每一个桶中相应放进了多少个元素**
>
> 

### 9. 桶排序

> 其实就是将插入排序小型化的过程，设计多个桶（数组）,每个桶代表不同的范围，入桶的时候采用算法排序对桶排序至关重要

### 10. 计数排序

> 1. 空间问题（最大值减最小值）
> 2. 稳定性（重新改变数组、用累加的方法）
> 3. 当首尾相差大的时候不适合用、当非整数的时候也不适合

### 11. 堆排序

> 

## 3. 线性表

### 1. 基本概念

![image-20220312113348767](/img/algorithm/image-20220312113348767.png)

> 前驱元素、后继元素、头结点、尾结点
>
> 可以是顺序存储，也可以是链式存储，可以分为线表也可以分为链表

### 3. 顺序表

##### 1. 实现

```java
public class SequenceList<T>{
    //存储元素的数组
    private T[] eles;
    //记录当前顺序表中的元素个数
    private int N;
    
    public SequenceList(int capacity){
        else = (T[])new Object[capacity];
        N=0;
    }
    
    //将一个线性表置为空表
    public void clear(){
        N=0;
    }
    
    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }
    
    //获取线性表长度
    public int length(){
        return N;
    }
    
    //获取指定位置的元素
    public T get(int i){
        if(i<0||i>=N){
            throw new RuntimeException("当前元素不存在");
        }
        return eles[i];
    }
    
    //向线性表中添加元素t
    public void insert(T t){
        if(N==eles.length){
            throw new RuntimeException("当前表已满");
        }
        else[N++] = t;
    }
    
    //在元素i出添加元素t
    public void insert(int i,T t){
        if(N==eles.length){
            throw new RuntimeException("当前表已满");
        }
        
        if(i<0||i>N){
            throw new RuntimeException("插入位置不合法");
        }
        
        for(int index=N;index>i;index--){
            eles[index] = eles[index-1];
        }
        
        else[i]=t;
        N++;
    }
    
    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        if(i<0 || i>N-1){
            throw new RuntimeException("当前要删除的元素不存在");
        }
        
        T result = eles[i];
        
        for(int index=i;index<N-1;index++){
            eles[index] = eles[index+1];
        }
        
        N--;
        return result
    }
    
    //查询t元素顶一次出现的位置
    public int indexOf(T t){
        if(t==null){
            throw new RuntimeException("查找的元素不合法")
        }
        
        for(int i=0;i<N;i++){
            if(eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }
}
```

##### 2. 遍历

> 1. 实现Iterable接口，重写iterator方法
> 2. 内部提供一个内部类SIterator，实现Iterator接口，重写hasNext方法和next方法