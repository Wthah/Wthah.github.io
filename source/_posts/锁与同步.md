###### 进程和线程的区别

> 本质区别在于是否单独占有`内存地址空间及其它系统资源`
>
> - 进程数据共享复杂但是同步简单
> - 线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步困难
> - 进程是操作系统资源分配的基本单位、而线程是操作系统进行调度的基本单位

###### 上下文切换

> 多线程运行会进行上下文切换，此操作会消耗大量的CPU时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题

###### 继承Thread类

```java
package com.wshen.baoqing.runner;

public class MyThread extends Thread{
    @Override
    public void run(){
        System.out.println("1");
    }

    public static void main(String[] args) {
        Thread thread = new MyThread();
        thread.start();
    }
}
```

`不可以多次调用start否则报错`

###### 实现Runnable接口

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(1);
    }
 }
```

###### Thread类中的几个常用方法

> 静态方法：
>
> - currentThread()
> - yield()
> - sleep()
>
> 一般方法：
>
> - join()
> - start()

###### Thread类与Runnable接口的比较

> - Runnable接口更加灵活
> - Runnable更符合面向对象
> - 降低了线程对象和线程任务的耦合性、
> - 推荐Runnable

###### Callable接口

- Future

  ```java
  public class MyCallableTask implements Callable<Integer> {
      @Override
      public Integer call(){
          return 99;
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // Future
          ExecutorService service = Executors.newCachedThreadPool();
          Future<Integer> future = service.submit(new MyCallableTask());
          System.out.println(future.get());
  
          // FutureTask
          FutureTask<Integer> futureTask = new FutureTask<Integer>(new MyCallableTask());
          service.submit(futureTask);
          System.out.println(futureTask.get());
      }
  }
  ```

- FutureTask

  ```java
  public class MyCallableTask implements Callable<Integer> {
      @Override
      public Integer call(){
          return 99;
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          // Future
          ExecutorService service = Executors.newCachedThreadPool();
          Future<Integer> future = service.submit(new MyCallableTask());
          System.out.println(future.get());
  
          // FutureTask
          FutureTask<Integer> futureTask = new FutureTask<Integer>(new MyCallableTask());
          service.submit(futureTask);
          System.out.println(futureTask.get());
      }
  }
  ```

###### FutureTask

```java
/**
 *
 * state可能的状态转变路径如下：
 * NEW -> COMPLETING -> NORMAL
 * NEW -> COMPLETING -> EXCEPTIONAL
 * NEW -> CANCELLED
 * NEW -> INTERRUPTING -> INTERRUPTED
 */
private volatile int state;
private static final int NEW = 0;
private static final int COMPLETING = 1;
private static final int NORMAL = 2;
private static final int EXCEPTIONAL = 3;
private static final int CANCELLED = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED = 6;
```

##### 线程组

```java
package com.wshen.baoqing.runner;

public class MyThreadGroup {
    public static void main(String[] args) {
        Thread thread =  new Thread(new MyRunnable());
        thread.start();
        System.out.println("当前线程组名字: " + Thread.currentThread().getThreadGroup().getName());
    }
}
```

`防止上级被下级线程引用而无法有效被GC回收`

###### 线程的优先级

> - 只是给操作系统一个建议，操作系统不一定会采纳
> - 线程的最大优先级小于线程组的最大优先级

###### 线程组的常用方法

- 复制线程数组给线程组
- 线程组统一异常处理

```java
package com.wshen.baoqing.runner;

public class MyThreadGroup {
    public static void main(String[] args) {
//        Thread thread =  new Thread(new MyRunnable());
//        thread.start();
//        System.out.println("当前线程组名字: " + Thread.currentThread().getThreadGroup().getName());

        ThreadGroup threadGroup1 = new ThreadGroup("group1"){
            public void uncaughtException(Thread t, Throwable e){
                System.out.println(t.getName() + e.getMessage());
            }
        };

        Thread t1 = new Thread(threadGroup1, new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException("测试");
            }
        });
        t1.start();
    }
}
```

###### 线程组的数据结构

```java
public class ThreadGroup implements Thread.UncaughtExceptionHandler {
 private final ThreadGroup parent; // ⽗亲ThreadGroup
 String name; // ThreadGroupr 的名称
 int maxPriority; // 线程最⼤优先级
 boolean destroyed; // 是否被销毁
 boolean daemon; // 是否守护线程
 boolean vmAllowSuspension; // 是否可以中断
 int nUnstartedThreads = 0; // 还未启动的线程
 int nthreads; // ThreadGroup中线程数⽬
 Thread threads[]; // ThreadGroup中的线程
 int ngroups; // 线程组数⽬
 ThreadGroup groups[]; // 线程组数组 
}
```

###### 操作系统中的线程状态转换

> - new
> - ready
> - waiting
> - running
> - terminated

###### java线程的六个状态

###### new

```java
package com.wshen.baoqing.runner;

public class ThreadStatus {
    public static void main(String[] args) {
        // 还没调用start()方法
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // 会改变TreadStatus的值
        thread.start(); // 再次调用IllegalThreadStateException
    }
}
```

###### Runnable

> 包括ready和running状态

###### Blocked

> 等待锁释放

###### Waiting

> - wait()
>
> - join
>
> - park()

###### TIMED_WAITING

> - sleep(long millis)
> - wait(long millis)
> - join(long millis)
> - parkNanos

###### Terminated

> 终止状态，此时线程已执行完毕

###### 状态转换

- Blocked和Runnable
- Waiting和Runnable转换
  - wait释放锁
  - join不释放锁
- Timed_waiting和Runnable转化
  - sleep并不释放锁

# 锁与同步

###### 对象锁

```java
package com.wshen.baoqing.runner;

public class ObjectLock {
    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock){
                    for (int i = 0; i < 5; i++) {
                        System.out.println("a"+i);
                    }
                }
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock){
                    for (int i = 0; i < 5; i++) {
                        System.out.println("b"+i);
                    }
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

###### 等待通知机制

```java
package com.wshen.baoqing.runner;

import lombok.SneakyThrows;

public class ObjectLock {
    private static Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @SneakyThrows
            @Override
            public void run() {
                synchronized (lock){
                    for (int i = 0; i < 5; i++) {
                        System.out.println("a"+i);
                        lock.notify();
                        lock.wait();
                    }
                }
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @SneakyThrows
            @Override
            public void run() {
                synchronized (lock){
                    for (int i = 0; i < 5; i++) {
                        System.out.println("b"+i);
                        lock.notify();
                        lock.wait();
                    }
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

###### 信号量

`volatite只能进行原子操作，所以非原子操作要上锁`

```java
package com.wshen.baoqing.runner;

import lombok.SneakyThrows;

public class MyVolatile {
    private static volatile int signal = 0;
    public static void test(){

    }
    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @SneakyThrows
            @Override
            public void run() {
                while(signal<5){
                    if(signal%2==0){
                        System.out.println("a"+signal);
                        synchronized (this){
                            signal++;
                        }
                    }
                }
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @SneakyThrows
            @Override
            public void run() {
                while(signal<5){
                    if(signal%2!=0){
                        System.out.println("b"+signal);
                        synchronized (this){
                            signal++;
                        }
                    }
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

###### 管道

> - PipeWriter
> - PipeReader

###### ThreadLocal

`弱引用Map来实现，线程本地变量`、

`ThreadLocalMap独有` `ThreadLocal作为key从而保证每个线程取出的Value不同`

```java
package com.wshen.baoqing.runner;

public class MyThreadLocal {
    static ThreadLocal<String> threadLocal = new ThreadLocal<>();
    private static class Thread1 implements Runnable{
        ThreadLocal<String> threadLocal;

        public Thread1(ThreadLocal<String> threadLocal) {
            this.threadLocal = threadLocal;
        }

        @Override
        public void run() {
            threadLocal.set("1");
            System.out.println(threadLocal.get());
        }
    }
    private static class Thread2 implements Runnable{
        ThreadLocal<String> threadLocal;

        public Thread2(ThreadLocal<String> threadLocal) {
            this.threadLocal = threadLocal;
        }

        @Override
        public void run() {
            threadLocal.set("2");
            System.out.println(threadLocal.get());
        }
    }
    public static void main(String[] args) {
        Thread thread = new Thread(new Thread1(threadLocal));
        Thread thread1 = new Thread(new Thread2(threadLocal));
        thread.start();
        thread1.start();
    }
}
```

`如果在每个线程中声明⼀些私有变量来进⾏操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接`

###### InheritableThreadLocal

> 子线程可继承

# 并发编程两个问题

###### 线程之间如何通信、线程之间如何同步

> - 消息传递并发模型
> - 共享内存并发模型（java)

###### ![image-20220818184056555](C:\Users\Megumi\AppData\Roaming\Typora\typora-user-images\image-20220818184056555.png)

###### 共享内存并发模型

> - `主内存`存储共享变量
>
> - 线程-`本地内存` 存储共享变量副本
> - 两个线程的通信必须要经过主内存
> - 只有在发现本地内存更新了才去主内存中读取这个主内存，并且更新本地内存
> - JMM（java内存模型）通过控制主内存与本地内存之间的交互来提供内存可见性的保证
>   - 主内存：堆内存和方法区
>   - 私有内存：程序计数器、本地方法栈、虚拟机栈

###### 重排序

```java
a = b + c;
d = e - f ;
```

> 指令重排可以保证串行予以一直，但是`没有义务保证`多线程间的语义也一致，所以指令重排会导致一些问题

###### JMM和内存一致性模型

###### Happens-before

###### Volatile

> - 保证变量的内存可见性
> - 防止volatile变量和普通变量进行重排序
>   - 内存屏障 写操作 禁止上边的普通写和volatile发生指令重排 禁止下边的volatile读写与自己重排StoreStore StoreLoad 写 LoadLoad LoadStore
> - 与锁的优劣
>   - 锁能保证一个临界区代码
>   - volatile只能保证一个变量