---
title: 消息中间件
date: 2023/4/10 11:21:25
tags:
  - Message
categories:
  - 分布式
cover: /img/message/message.jpg
---



# 消息队列

## 相关概念

###### 什么是MQ

> message queue，本质是个队列，FIFO先入先出逻辑解耦+物理解耦

###### 为什么要用MQ

> - 流量消峰
> - 应用解耦
> - 异步处理（A不用等B，只要B发送一个消息给A）

###### MQ分类

- ActiveMQ

  > 1. 单机吞吐量万级
  > 2. 时效性ms级，可用性高（主从架构）
  > 3. 消息可靠性较低的概率丢失
  > 4. 维护少，高吞吐量少用

- Kafka

  > 1. 百万级吞吐量
  > 2. 分布式，不会丢数据，不会导致不可用
  > 3. 队列超过64，支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新慢，相应时间长

- RocketMQ

  > 1. 十万级吞吐量
  > 2. 分布式，消息可以做到0丢
  > 3. 支持10亿急别的消息堆积
  > 4. 支持的客户端语言不多（java，c++）

- RabbitMQ

  > 1. 万级吞吐量
  > 2. 支持多语言
  > 3. 社区活跃

## RabbitMQ

###### 四大核心概念

1. 生产者：发送消息
2. 交换机：一方面接受来自生产者的消息，另一方面将消息推送到队列中。交换机必须确切知道如何处理他接收到的消息，推送到特定队列、推送到多队列、亦或是把消息丢弃
3. 队列：大的消息缓存区
4. 消费者：消费消息

###### RabbitMQ工作原理

![image-20230221133239883](C:\Users\Megumi\AppData\Roaming\Typora\typora-user-images\image-20230221133239883.png)

1. Broker：接受和分发消息的应用
2. Virtual host：出于多租户和安全因素设计的
3. Connection：publisher/consumer和broker之间的TCP连接
4. Channel：Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销
5. Exchange：到达Broker的第一站，根据分发规则，匹配查询表中的routing key，分发到queue去，常见的类型有direct(point to point),topic(publish-subsrcibe) and fanout(multicast)
6. Queue
7. Binding: exchange和queue之间的虚拟连接，binding中可以包含routing key，Binding信息被保存到exchange中的查询表

# 工作队列

## 轮询分发

###### 抽象类工具

```java
package com.wshen.baoqing.rabbitmq;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;


public class RabbitMqUtils {
    public static Channel getChannel() throws Exception{
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("127.0.0.1");
        factory.setUsername("guest");
        factory.setPassword("guest");
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        return channel;
    }


}
```

###### 启动两个工作线程

```java
package com.wshen.baoqing.rabbitmq;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

public class Worker01 {
    private static final String QUEUE_NAME="hello";

    public static void main(String[] args) throws Exception{
        Channel channel = RabbitMqUtils.getChannel();
        DeliverCallback deliverCallback = (consumerTag,delivery)->{
            String receivedMessage = new String(delivery.getBody());
            System.out.println("接收到的消息是："+receivedMessage);
        };
        CancelCallback cancelCallback = (consumerTag)->{
            System.out.println(consumerTag+"消费者取消消费接口回调逻辑");
        };
        System.out.println("c2 消费者启动等待消费......");
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);

    }
}
```

###### 启动一个发送线程

```java
package com.wshen.baoqing.rabbitmq;

import com.rabbitmq.client.Channel;

import java.util.Scanner;

public class Task01 {
    private static final String QUEUE_NAME="hello";

    public static void main(String[] args) throws Exception{
        Channel channel = RabbitMqUtils.getChannel();
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String message = scanner.next();
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());
            System.out.println("发送消息完成："+ message);
        }
    }
}
```

## 消息应答

###### 概念

> 消费者再接收到消息，并且处理该消息过后，告诉RabbitMQ它已经处理了，rabbitMQ可以把该消息删除

###### 自动应答

> 在消息发送是就被认为已经传送成功

###### 消息应答方式

- Channel.basicAck
- Channel.basicNack
- Channel.basicReject(不处理直接丢弃)

###### Multiple的解释



###### 消息重新入队

> RabbitMQ未收到消费者的ack确认

## RabbitMQ持久化

###### 队列持久化

```java

```

###### 消息持久化

###### 不公平分发

```java
int prefetchCount = 1;
channel.basicQos(prefetchCount);
```

###### 预取值

> 设定缓冲区大小

# 发布确认

> broker发送一个确认给生产者

```java
Channel channel = connection.createChannel();
channel.confirmSelect();
```

###### 单个确认发布

> 同步确认发布

###### 批量确认发布

> 不知道是那条消息发生错误

###### 异步确认发布

# 交换机（Exchange）

###### 交换机类型

1. direct
2. topic
3. headers
4. fanout 广播

# 死信队列

> 当消息消费异常时，将消息投入死信队列中。
>
> 保证订单业务消息数据不丢失

###### 来源

1. 消息TTL过期
2. 队列达到最大长度
3. 消息被拒绝

![image-20230224095234141](image-20230224095234141.png)

# 延迟队列

> 在指定时间到了以后或之前取出和处理

# 发布确认高级

###### 回退消息

mandatory

###### 备份交换机

# RabbitMQ特性

###### 幂等性

设置全局id

Redis原子性用setnx

###### 优先级队列

###### 惰性队列

> 惰性队列会尽可能的将消息存入磁盘中，而在消
>
> 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持
>
> 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致
>
> 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了

# 集群

###### Haproxy+Keepalive

###### Federation（网络延迟）+Shovel保证数据可靠

