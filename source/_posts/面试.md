---
title: 知识点
date: 2022/7/6 11:21:25
tags:
  - 知识点
categories:
  - 面试
cover: /img/11.jpg
---



# 面试

## JAVA

### String、StringBuilder、StringBuffer的区别

> `StringBuilder`: 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。
>
> `StringBuilder`: 不保证同步，所以线程不安全

### Sleep和wait的区别

> `Sleep`: 释放cpu不释放锁
>
> `wait`: 释放cpu也释放锁，并且要等待notify() 或者 notifyAll() 才会被唤醒

> `线程五种状态`：新建（new）、就绪（Runnable）、阻塞（Blocked）、运行（Running）、死亡（Dead）

## 如何进行深克隆

> `原型模式`：由一个原型new出所有类
>
> `浅克隆`：实现Cloneable接口
>
> `深克隆`：序列化

> `24种设计模式`：

## ThreadLocal

> `ThreadLocal` 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景

###### 与Synchronized的区别

> 一个适用于数据隔离，一个适用于数据共享
>
> `Synchronized`利用了锁的机制，而ThreadLocal是通过提供副本，保证隔离，`ThreadLocal`作为`Thread`中的`ThreadLocalMap`的Key，而ThreadLocalMap又是每个线程独有的，就能保证取到的value不同

```java
public class ThreadLocalDemo{
    private static ThreadLocal<String> localVar = new ThreadLocal<String>();
}
```

###### set方法

```java
 public void set(T value) {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，
        //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            // 初始化thradLocalMap 并赋值
            createMap(t, value);
    }
```

###### ThreadLocalMap -- 作为Thread Local的静态内部类

```java
static class ThreadLocalMap {
 
        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;
 
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
 
        
    }
```

###### 内存泄漏

> `Key`和`ThreadLocal`之间的关系是弱引用，弱引用的特点是，只要这个对象存在弱引用，那么下次这个`GC`是这个对象一定会被删除，那么就会存在key为空的value，所以要将值直接删除。

### InheritableThreadLocal作用和实现方式

> https://blog.csdn.net/Mr1ght/article/details/118385003?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165709687716781647541105%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165709687716781647541105&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118385003-null-null.142^v31^pc_rank_34,185^v2^tag_show&utm_term=+InheritableThreadLocal&spm=1018.2226.3001.4187

> 基于`ThreadLocal`实现，区别在于他可以传递值给子线程，每一个Thread都有一个`inheritableThreadLocals`属性，在创建子线程时，会把父线程的Entry数组丢给子线程。如果Value是一个非基本类型对象，那么传递的是引用。子线程改变父线程也会改变。

###### 带来的问题

> `线程不安全`：子线程改变，父线程改变
>
> `线程池可能失效`：因为父线程的TLMap是通过Thread的`init`方法的时候进行赋值给子线程的，而线程池在执行异步任务时可能不再需要创建新的线程了，因此也就不会再传递父线程的TLMap给子线程了

### 如何解决线程池异步传值问题

> `TransmittableThreadLocal`:简单的原理就是TTL 中的holder持有的是当前线程内的所有本地变量,被包装的run方法执行异步任务之前，会使用replay进行设置父线程里的本地变量给当前子线程，任务执行完毕，会调用restore恢复该子线程原生的本地变量

## HashMap

### jdk1.7和1.8的区别

### 为什么线程不安全

### 为什么采用红黑树
