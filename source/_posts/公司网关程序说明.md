## 程序入口

### ModbusServer

```java
public void start() {

        ServerBootstrap sbs = new ServerBootstrap().group(bossGroup, workerGroup)
                .option(ChannelOption.SO_REUSEADDR, true)
                .childOption(ChannelOption.SO_KEEPALIVE, true)
                .childOption(ChannelOption.TCP_NODELAY, true)
                .channel(NioServerSocketChannel.class)
                .handler(new LoggingHandler(LogLevel.WARN))
                .childHandler(new ModbusChannelInitializer());
        try {
            log.info("TCP服务启动完毕,port={}", this.port);
            ChannelFuture future = sbs.bind(port).sync();
            future.channel().closeFuture().sync();
        } catch (Exception e) {
            log.error("start error", e);
        } finally {
            stop();
        }
    }
```

## 通道

### `ModbusChannelInitializer`

```java
@Override
    protected void initChannel(SocketChannel ch) throws Exception {

        final EventExecutorGroup group = new DefaultEventExecutorGroup(Runtime.getRuntime().availableProcessors() * 2);
        ChannelPipeline pipeline = ch.pipeline();
        pipeline
                .addLast("ping", new IdleStateHandler(30, 30, 60, TimeUnit.SECONDS))
                .addLast("requestBodyDecoder", new RequestBodyDecoder())
                .addLast("modbusServerLastHandler",new ModbusServerLastHandler())
            //    .addLast(group,"alert",new AlertHandler())
                .addLast(group, "MyDatabaseAccessingHandler", new MyDatabaseAccessingHandler());
              //  .addLast("urgentEventHandler", new UrgentEventHandler());
    }
```

##### `requestBodyDecoder`--`包过滤器`

```java
@Override
	//主机配置数据头长度
    private static final int HEAD_LEN = 24;
    private int MSG_LEN = 0;
    
	protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List<Object> out) throws Exception {
        try {
            switch (state()) {

                case READ_LENGTH:
                    buf.markReaderIndex();
                    ByteBuf headBuf = buf.readBytes(HEAD_LEN);
                    headBuf.skipBytes(2);
                    MSG_LEN = headBuf.readUnsignedShortLE();
                    //初始化 包大小
                    checkpoint(RequestBodyDecoderState.READ_CONTENT);
                case READ_CONTENT:
                    if (MSG_LEN > 0) {
                        buf.resetReaderIndex();
                        ByteBuf frame = buf.readBytes(MSG_LEN);
                        checkpoint(RequestBodyDecoderState.READ_LENGTH);
                        out.add(frame);
                    }
                    break;
                default:
                    log.error(state().name() + "  Shouldn't reach here.");
                    //throw new Error("Shouldn't reach here.");
            }

        } finally {
            //ReferenceCountUtil.release(buf);
        }
    }
```

> #3 `private static final int HEAD_LEN = 24;`  // 包头24
>
> #14 `MSG_LEN = headBuf.readUnsignedShortLE();` // 包体通过第三第四个字节获得包体长度

##### `modbusServerLastHandler`--处理程序用于解析数据头和数据体，返回`ResponeHeadAndBody`，供后边的`MyDatabaseAccessingHandler`使用

```java
@Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{

        if (ObjectUtils.isNull(msg)) {
            return;
        }
        //   log.info("channelRead0 has begining " +getRemoteAddress(ctx));
        //  log.info("SomCommunicationHandler收到SOM的二进制形式指令： " + ByteBufUtil.hexDump(m));
        // log.info("SomCommunicationHandler收到SOM的ASCII形式指令： " + m.toString(Charset.forName("US-ASCII")));
        try {

            Channel channel = ctx.channel();
            readBuf = (ByteBuf) msg;
            readBuf.markReaderIndex();
            log.info("IP:网关返回原始数据  " + getRemoteAddress(ctx)+ "----" + ByteBufUtil.hexDump(readBuf).toUpperCase());
            readBuf.resetReaderIndex();
            RequestHead requestHead = MsgHeadParser.parserHexToObj(readBuf);
            log.info("网关头数据:"+ requestHead.getPID());
            readBuf.resetReaderIndex();
            String msgType = requestHead.getMsgType();
            Session session = Session.buildSession(channel, requestHead.getPID());
            sessionManager.put(Session.buildId(session.getChannel()), session);
            sessionManager.putStr(Session.buildId(session.getChannel()),msgType);
            //   System.out.println("发送时间: " + requestHead.getCreateTime() +" "+ msgType);

            switch (msgType) {
                case "30":
                    readBuf.resetReaderIndex();
                    ctx.fireChannelRead(getUpdata(ctx, readBuf.copy()));
                    break; //上送传感器数据
                case "31":

                    break; //心跳

                case "32":
                    readBuf.resetReaderIndex();
                    // ResponeHeadAndBody responeHeadAndBody = HeadAndBodyParser.parserHexToObj(readBuf.copy());
                    // log.info("getRespId:  " + responeHeadAndBody.getRequestHead().getRespId());
                    break; //下发指令

                case "33":
                    break;//控制指令
                case "34":
                    readBuf.resetReaderIndex();
                    //正常处理
                    ctx.fireChannelRead(getUpdata(ctx, readBuf.copy()));
                    //告警处理
                    //exeUrgentEvent(ctx,readBuf);
                    break; //报警指令
                case "35": // 同步系统时间
                    sendDateTime(ctx, requestHead);
                default: //可选
                    //语句
            }

            // readBuf.resetReaderIndex();
            // ResponeHeadAndBody responeHeadAndBody = HeadAndBodyParser.parserHexToObj(readBuf);

            // log.info("responeHeadAndBody:  " + responeHeadAndBody);
            if (handleData()) {
                ctx.fireChannelRead(msg);
            }
        } catch (Exception e){
            log.error("channelRead 发生异常:{}", e);
        }
        finally {
        }
    }
```

> - #17 将数据头解析通过`MsgHeadParser
>
> ```java
> /***
>      * @Author john
>      * @Description  客户端返回报文协议解析为对象
>      * @Date 2019/5/21 20:42
>      * \1B\30\EC 00\13 05 13 0B 33 03\01 02\03 04 05 06 F3 16\00 00\00 00 00 00\
>      * +---+----+---+---+----+---+----+------+----+---+----+------+----+----+
>      *    | 开始位(1) |协议类型(1)|长度(2) | 时间(6) |CRC校验(2)|PID(6) |编号(2) |预留(4) |
>      *
>      * @Param [msg]
>      * @return com.wshen.message.RequestHead
>      **/
>     public static RequestHead parserHexToObj(ByteBuf msg){
> 
>         RequestHead requestHead = new RequestHead();
>         try{
>             //CRC校验
>             msg.markReaderIndex();
>             log.info("解析head:"+ ByteBufUtil.hexDump(msg));
>             msg.resetReaderIndex();
>             requestHead.setStartBit(MsgByteBufUtils.parserHexString(msg.readByte())); //开始位
>             requestHead.setMsgType(MsgByteBufUtils.parserHexString(msg.readByte())); //协议类型
>             requestHead.setHeadLen(String.valueOf(msg.readUnsignedShortLE())); //长度
>             msg.resetReaderIndex(); 
>             requestHead.setCreateTime(MsgByteBufUtils.parserHexToIntString(msg,4,6,"")); //时间
>             msg.skipBytes(2);
>             requestHead.setPID(MsgByteBufUtils.parserHexToIntString(msg,0,6,"")); //pid
> 
>             // ByteBuf copy = msg.copy(12, 6);
>             ByteBuf copy = msg.slice(12,6);
>             //copy.retain();
>             requestHead.setPID(ByteBufUtil.hexDump(copy)); //pid
>             log.info("解析PID:"+ requestHead.getPID());
>             //copy.release();
>             requestHead.setRespId(MsgByteBufUtils.parserHexToString(msg,0,2,"")); //编号
>         }catch (Exception e){
>             log.error(ResultCode.PARAM_TYPE_ERROR.getMessage()+"原因为: {}",e);
>             //throw new ServiceException(ResultCode.PARAM_TYPE_ERROR);
>         }finally{
>             // ReferenceCountUtil.release(msg);
>         }
>         return requestHead;
>     }
> ```
>
> - #27 调用getUpdata(),将数据体和数据头解析
>
> ```java
> //解析 传感器数据
>     private ResponeHeadAndBody getUpdata(ChannelHandlerContext ctx, ByteBuf msg) {
> 
>         try {
>             //所有协议 id+type组成的map对象
>             Map<Integer, Integer> idAndType =  protocolService.listIdAndTypeMap();
>             Map<Integer, Integer> equipProtocolRelation =  equipProtocolRelationService.listIdAndTypeMap();
>             // headAndBodyCalaculator.getHeadAndBody(msg);
>             return headAndBodyCalaculator.getHeadAndBody(msg, idAndType,equipProtocolRelation);
>         } finally {
>             if (msg != null) {
>                 ReferenceCountUtil.release(msg);
>             }
>         }
>     }
> ```
>
> > - #9 调用getHeadAndBody解析数据头和数据体
> >
> > ```java
> > private Map<Integer, Integer> equipProtocolRelation = null;
> > 
> > public ResponeHeadAndBody getHeadAndBody(ByteBuf msg, Map<Integer, Integer> idAndType, Map<Integer, Integer> idAndType2) {
> >     equipProtocolRelation = idAndType2;
> >     return this.getHeadAndBody(msg, idAndType);
> >  }
> > 
> > public ResponeHeadAndBody getHeadAndBody(ByteBuf msg, Map<Integer, Integer> idAndType) {
> > 
> >     ResponeHeadAndBody responeHeadAndBody = new ResponeHeadAndBody();
> >     RequestHead requestHead = this.doParserHead(msg);
> > 
> >     if (requestHead == null) {
> >       return null;
> >     }
> >     responeHeadAndBody.setRequestHead(requestHead);
> >     //ByteBuf bodyBuf = msg.copy(24, msg.writerIndex() - 24);
> >     ByteBuf bodyBuf = msg.slice(24, msg.writerIndex() - 24);
> >     //bodyBuf.retain();
> >     //bodyBuf.release();
> > 
> >     try {
> > 
> >       if (Integer.valueOf(requestHead.getHeadLen()) != msg.writerIndex()) {
> >         msg.resetReaderIndex();
> >         log.error(
> >                 ResultCode.MSG_BODY_LENGTH_ERROR.getMessage()
> >                         + " "
> >                         + requestHead.getCreateTime()
> >                         + " "
> >                         + requestHead.getRespId()
> >                         + "：{} {} {}",
> >                 requestHead.getHeadLen(),
> >                 msg.writerIndex(),
> >                 "错误内容：" + ByteBufUtil.hexDump(msg).toUpperCase());
> >         return responeHeadAndBody;
> >       }
> >       responeHeadAndBody.setResponeBodyList(this.doParserBody(bodyBuf, idAndType));
> >       return responeHeadAndBody;
> > 
> >     } finally {
> > 
> >     }
> >   }
> > }
> > ```
> >
> > > - #11 调用解析数据头
> > >
> > > - #38 解析数据体
> > >
> > > ```java
> > > @Override
> > >   protected List<MsgResponeBody> doParserBody(ByteBuf msg, Map<Integer, Integer> idAndType) {
> > > 
> > >     MsgResponeBody msgResponeBody = null;
> > >     StringBuffer sb = new StringBuffer();
> > >     // 清空原数据
> > >     List<MsgResponeBody> modbusResponeBodyList = new ArrayList<>();
> > >     ByteBuf copy = msg.duplicate();
> > >     sb.append("原始数据包：" + ByteBufUtil.hexDump(copy).toUpperCase()).append(":");
> > >     // 下一个block块的开始位置
> > >     int posit = 0;
> > >     int skipLen = 0;
> > > 
> > >     try {
> > > 
> > >       while (msg != null && msg.capacity() - posit > 0) {
> > > 
> > >         msgResponeBody = new MsgResponeBody();
> > >         skipLen = msg.readUnsignedShortLE();
> > >         msgResponeBody.setBodyLen(String.valueOf(skipLen)); //总长度
> > >         msgResponeBody.setPosit(String.valueOf(MsgByteBufUtils.byteToInt(msg.readByte()))); //位置 对应串口位置
> > >         msgResponeBody.setBaudRate(String.valueOf(MsgByteBufUtils.byteToInt(msg.readByte()))); //波特率
> > >         msgResponeBody.setAcqFreq(String.valueOf(msg.readUnsignedShortLE())); //采集频率
> > >         msgResponeBody.setUpRate(String.valueOf(msg.readUnsignedShortLE())); //上传频率
> > >         // msgResponeBody.setOrderCode(String.valueOf(msg.readUnsignedShortLE()));
> > >         msgResponeBody.setUniqueNumHi(String.valueOf(MsgByteBufUtils.byteToInt(msg.readByte()))); //命令标识
> > >         msgResponeBody.setUniqueNumLo(String.valueOf(MsgByteBufUtils.byteToInt(msg.readByte()))); //命令表示
> > >         int flag = MsgByteBufUtils.byteToInt(msg.readByte());
> > >         // 0 正常
> > >         // 1通讯异常
> > >         // String status = (flag == 0 ? "正常":"通讯异常");
> > >         msgResponeBody.setCommStatus(String.valueOf(flag)); //通讯状态
> > > 
> > >         if (flag == 0) {
> > >           if (msg.readableBytes() >= (skipLen - 16)) { //指令
> > >             // java.lang.IndexOutOfBoundsException: index: 1231, length: 50416 (expected: range(0,
> > >             // 1296))
> > >             //ByteBuf modbusBody = msg.copy(16 + posit, skipLen - 16);
> > >             ByteBuf modbusBody = msg.slice(16 + posit, skipLen - 16); //指令
> > >             //ByteBuf modbusBody = msg.slice(16 + posit, skipLen - 16);
> > >             sb.append("  当前指令包：" + ByteBufUtil.hexDump(modbusBody.duplicate()).toUpperCase()).append("--");
> > > 
> > >             // 处理 232 设备
> > >             if (StringUtils.isNotEmpty(msgResponeBody.getPosit())
> > >                     && msgResponeBody.getPosit().length() >= 3) {
> > > 
> > >               ModbusResponeBody body =
> > >                       r232OrderCalaculator.parser(
> > >                               modbusBody,
> > >                               String.valueOf(
> > >                                       idAndType.get(
> > >                                               equipProtocolRelation.get(
> > >                                                       Integer.valueOf(msgResponeBody.getUniqueNumHi())))));
> > > 
> > >               if (body != null) {
> > >                 msgResponeBody.setModbusResponeBody(body);
> > >               }
> > > 
> > >             } else {
> > >               // modbus返回值
> > >               ModbusResponeBody body = modbusOrderCalaculator.parser(modbusBody, null);
> > > 
> > >               if (body != null) {
> > >                 msgResponeBody.setModbusResponeBody(body);
> > >               }
> > >             }
> > >           } else {
> > >             ByteBuf modbusBody = msg.copy(16 + posit, skipLen - 16);
> > > 
> > >             // sb.append("
> > >             // 当前指令包："+ByteBufUtil.hexDump(modbusBody.copy()).toUpperCase()).append("--");
> > >             log.error(ResultCode.PRO_BODY_BLOCK_LENGTH_ERROR.getMessage() + ":" + sb.toString());
> > >           }
> > >         } else {
> > > 
> > >           if (skipLen >= 16) {
> > >             //ByteBuf modbusBody = msg.copy(16 + posit, skipLen - 16);
> > >             ByteBuf modbusBody = msg.slice(16 + posit, skipLen - 16);
> > >             if (StringUtils.isNotEmpty(msgResponeBody.getPosit())
> > >                     && msgResponeBody.getPosit().length() >= 3) {
> > > 
> > >               msgResponeBody.getModbusResponeBody().setDataLen("0");
> > >             } else {
> > > 
> > >               // modbus返回值
> > >               int addCode = MsgByteBufUtils.byteToInt(modbusBody.readByte());
> > >               if (addCode < 10) {
> > >                 msgResponeBody.getModbusResponeBody().setAddCode("0" + String.valueOf(addCode));
> > >               } else {
> > >                 msgResponeBody.getModbusResponeBody().setAddCode(String.valueOf(addCode));
> > >               }
> > >               // msgResponeBody.getModbusResponeBody().setAddCode(MsgByteBufUtils.parserHexString(modbusBody.readByte()));
> > >               msgResponeBody.getModbusResponeBody().setFuncCode(MsgByteBufUtils.parserHexString(modbusBody.readByte()));
> > >               msgResponeBody.getModbusResponeBody().setDataLen("0");
> > >             }
> > >           }
> > >         }
> > > 
> > >         posit += skipLen;
> > >         msg.resetReaderIndex();
> > >         if (msg.capacity() - posit > 0) {
> > >           msg.skipBytes(posit);
> > >         }
> > >         modbusResponeBodyList.add(msgResponeBody);
> > >       }
> > >     } catch (Exception e) {
> > >       log.error(ResultCode.PRO_BODY_BLOCK_LENGTH_ERROR.getMessage() + ":{},错误原因为:{}" ,sb.toString(), e);
> > >     } finally {
> > >       // ReferenceCountUtil.release(msg);
> > >       // ReferenceCountUtil.release(msg);
> > >       // msg.release();
> > >     }
> > >     return modbusResponeBodyList;
> > >   }
> > > ```
> > >
> > > > - #61 modbus解析返回的数据指令，返回ModbusResponseBody
> > > >
> > > > ```java
> > > > /***
> > > >  * @Author john
> > > >  * @Description 返回 485 数据对象
> > > >  * @Date 2019/5/21 19:43
> > > >  * @Param [msg]
> > > >  * @return com.wshen.message.ModbusResponeBody
> > > >  **/
> > > > public static ModbusResponeBody parserHexToObj(ByteBuf msg) {
> > > > 
> > > >     try {
> > > >         msg.markReaderIndex();
> > > >         byte[] modbusByte = new byte[msg.capacity()];
> > > >         msg.setIndex(0, modbusByte.length);
> > > >         msg.readBytes(modbusByte);
> > > >         msg.resetReaderIndex();
> > > >         log.info(ByteBufUtil.hexDump(msg).toUpperCase());
> > > >         ModbusResponeBody modbusResponeBody = new ModbusResponeBody();
> > > >         //crc校验
> > > >         if (CRCUtil.checkCrc(0, modbusByte.length - 2, modbusByte)) {
> > > > 
> > > >             msg.markReaderIndex();
> > > >             modbusResponeBody.setBodyByte(MsgByteBufUtils.parserHexToString(msg.duplicate(), 0, modbusByte.length - 2, ""));
> > > > 
> > > >             int addCode = MsgByteBufUtils.byteToInt(msg.readByte());
> > > >             if (addCode < 10) {
> > > >                 modbusResponeBody.setAddCode("0" + String.valueOf(addCode));
> > > >             } else {
> > > >                 modbusResponeBody.setAddCode(String.valueOf(addCode));
> > > >             }
> > > > 
> > > >             int funCode = MsgByteBufUtils.byteToInt(msg.readByte());
> > > >             if (funCode < 10) {
> > > >                 modbusResponeBody.setFuncCode("0" + String.valueOf(funCode)); //功能码
> > > >             } else {
> > > >                 modbusResponeBody.setFuncCode(String.valueOf(funCode));
> > > >             }
> > > > 
> > > >             int len = MsgByteBufUtils.byteToInt(msg.readByte()); //数据长度
> > > >             modbusResponeBody.setDataLen(String.valueOf(len));
> > > >             msg.resetReaderIndex();
> > > > 
> > > >             modbusResponeBody.setDataBody(MsgByteBufUtils.parserHexToString(msg, 3, len, "")); //数据
> > > >         } else {
> > > >             msg.markReaderIndex();
> > > >             modbusResponeBody.setBodyByte(MsgByteBufUtils.parserHexToString(msg.copy(), 0, modbusByte.length - 2, ""));
> > > > 
> > > >             int addCode = MsgByteBufUtils.byteToInt(msg.readByte());
> > > >             if (addCode < 10) {
> > > >                 modbusResponeBody.setAddCode("0" + String.valueOf(addCode));
> > > >             } else {
> > > >                 modbusResponeBody.setAddCode(String.valueOf(addCode));
> > > >             }
> > > >             int funCode = MsgByteBufUtils.byteToInt(msg.readByte());
> > > >             if (funCode < 10) {
> > > >                 modbusResponeBody.setFuncCode("0" + String.valueOf(funCode));
> > > >             } else {
> > > >                 modbusResponeBody.setFuncCode(String.valueOf(funCode));
> > > >             }
> > > >             int len = MsgByteBufUtils.byteToInt(msg.readByte());
> > > >             modbusResponeBody.setDataLen(String.valueOf(len));
> > > >             msg.resetReaderIndex();
> > > >             modbusResponeBody.setDataBody(MsgByteBufUtils.parserHexToString(msg, 3, len, ""));
> > > > 
> > > >             log.error("modbus CRC 数据校验错误：" +ByteBufUtil.hexDump(modbusByte).toUpperCase(),"modbus protocol CRC chk fail ");
> > > >         }
> > > >         return modbusResponeBody;
> > > > 
> > > >     } catch (Exception e) {
> > > >         log.error("modbus 数据解析错误：{},{},{}" ,ByteBufUtil.hexDump(msg).toUpperCase(),"modbus protocol CRC chk fail ",e);
> > > >     }finally{
> > > >         // ReferenceCountUtil.release(msg);
> > > >     }
> > > >     return null;
> > > > }
> > > > ```
> > >
> > > - #39 返回解析过后的数据头和数据体对象`ResponeHeadAndBody`

##### `MyDatabaseAccessingHandler` -- 最后处理，根据模板解析ResponeHeadAndBody对象，写入数据库

```java
@Override
    protected void decode(ChannelHandlerContext ctx, ResponeHeadAndBody msg, List<Object> out) throws Exception {

        //设备日志
        EquipmentAccessLog e = new EquipmentAccessLog();
        //设备状态  1 正常 2 报警  3在线   4 离线

        if (msg != null && msg.getResponeBodyList() != null && msg.getResponeBodyList().size() > 0) {

            String createTime = msg.getRequestHead().getCreateTime();
            Date acquisitionTime = DateUtil.parse(createTime, DateUtil.PATTERN_TIME_UNSEPA_FORMAT);
            LocalDateTime localDateTime = DateUtil.UDateToLocalDateTime(acquisitionTime);
            log.info("----------------------  " + acquisitionTime);
            String pid = msg.getRequestHead().getPID();
            String msgType = msg.getRequestHead().getMsgType();

            //处理紧急告警
            if ("32".equalsIgnoreCase(msgType)) {

            }

            log.info("RequestHead" + msg.getRequestHead());
            msg.getResponeBodyList()
                    .forEach(
                            x -> {
                                log.info("msg.getRequestHead().getPID() -----" + pid);
                                //   e.setEquipPid(pid);
                                e.setCreateTime(acquisitionTime);
                                e.setRetype(msgType);
                                // 设备状态
                                //    equipmentRuntimeInfo.setEquipPid(pid);

                                // 通信是否正常 0 为正常 其它值 为不正常
                                if (ObjectUtil.isNotEmpty(x.getUniqueNumHi())) {

                                    List<Integer> equipIds =
                                            protocolService.selectEquipIdByIdDI(Integer.valueOf(x.getUniqueNumHi()));
	// List<Integer> integers = protocolService.selectEquipIdByIdDI(1);
                                    //保存设备状态信息
                                    List<EquipmentRuntimeInfo> equipmentRuntimeInfos = new LinkedList<>();
                                    for (Integer equipId : equipIds) {
                                        EquipmentRuntimeInfo equipmentRuntimeInfo = new EquipmentRuntimeInfo();
                                        if (ObjectUtil.isNotEmpty(x.getCommStatus())) {
                                            if (!x.getCommStatus().equalsIgnoreCase("0")) {
                                                log.info("设备状态信息：" + x.getCommStatus());
                                                if (ObjectUtil.isNotEmpty(equipId)) {
                                                    equipmentRuntimeInfo.setEquipId(equipId);
                                                    equipmentRuntimeInfo.setRunStatus("4");
                                                    equipmentRuntimeInfo.setCreateTime(localDateTime);
                                                    //equipmentRuntimeInfoService.insertSelective(equipmentRuntimeInfo);
                                                    equipmentRuntimeInfos.add(equipmentRuntimeInfo);
                                                }
                                            }
                                            if (x.getCommStatus().equalsIgnoreCase("0")) {
                                                if (x.getModbusResponeBody() != null) {
                                                    equipmentRuntimeInfo.setEquipId(equipId);
                                                    if (x.getModbusResponeBody() != null
                                                            && StringUtils.isNotEmpty(x.getModbusResponeBody().getDataLen())
                                                            && x.getModbusResponeBody().getDataLen().equals("0")) {
                                                        equipmentRuntimeInfo.setRunStatus("3");

                                                    } else {
                                                        equipmentRuntimeInfo.setRunStatus("1");
                                                    }
                                                }
                                                equipmentRuntimeInfo.setCreateTime(localDateTime);
                                                if (ObjectUtil.isNotEmpty(equipmentRuntimeInfo) && ObjectUtil.isNotEmpty(equipmentRuntimeInfo.getEquipId())) {
                                                    equipmentRuntimeInfos.add(equipmentRuntimeInfo);
                                                }
                                            }
                                        } else {
                                            log.error("设备状态异常,设备编号为：" + equipId);
                                        }
                                    }
                                    if (equipmentRuntimeInfos != null) {
                                        if (equipmentRuntimeInfos.size() > 0) {
                                            equipmentRuntimeInfoService.insertSelectiveList(equipmentRuntimeInfos);
                                        }
                                    }
                                    //解析数据
                                    if (equipIds.size() > 0) {
                                        Integer equipId = equipIds.get(0);
                                        if (ObjectUtil.isNotEmpty(x.getCommStatus())) {
                                            if (x.getCommStatus().equalsIgnoreCase("0")) {

                                                if (x.getModbusResponeBody() != null) {
                                                    String addCode = x.getModbusResponeBody().getAddCode();
                                                    log.info("地址码  " + addCode);
                                                    e.setResponseContent(x.getModbusResponeBody().getDataBody());
                                                    e.setResponseLastContent(x.getModbusResponeBody().getBodyByte());
                                                    e.setEquipId(equipId);
                                                    e.setRequestCode(x.getUniqueNumHi() + "-" + x.getUniqueNumLo());

                                                    // 查询解析模板明细
                                                    equipmentAccessLogService.insertLog(e);
                                                    log.info(
                                                            "getDataLen()" + "----" + x.getModbusResponeBody().getDataLen() + " 值");

                                                    log.info("modbusResponeBody: " + x.getModbusResponeBody().toString());
                                                    if (x.getModbusResponeBody() != null
                                                            && StringUtils.isNotEmpty(x.getModbusResponeBody().getDataLen())
                                                            && x.getModbusResponeBody().getDataLen().equals("0")) {

                                                        log.info(
                                                                "getDataLen"
                                                                        + "----"
                                                                        + x.getUniqueNumLo()
                                                                        + "-"
                                                                        + x.getUniqueNum()
                                                                        + "-"
                                                                        + x.getModbusResponeBody().getAddCode()
                                                                        + "----"
                                                                        + x.getModbusResponeBody().getDataBody());

                                                    } else {
                                                        log.info("getDataLen()" + "----" + x.getModbusResponeBody().getDataLen() + " 值");
                                                        // 解析 数据
                                                        vo.setEquipPid(pid);
                                                        vo.setEquipCid(addCode);
                                                        vo.setOrderCode(x.getPosit());
                                                        vo.setProId(Integer.valueOf(x.getUniqueNumHi()));
                                                        vo.setOrderSeq(Integer.valueOf(x.getUniqueNumLo()));

                                                        log.info("parseOrder method " + "----" + x.getModbusResponeBody().getDataBody());
                                                        // 解析数据
                                                        log.info("解析模板赋值对象：" + vo);
                                                        ProtocolEntity protocolEntity =
                                                                protocolService.selectByProtocolOfRelationIdByDI(x.getUniqueNumHi()).get(0);
                                                        if (ObjectUtil.isNotEmpty(protocolEntity)) {
                                                            parseOrder(x, localDateTime, addCode, pid, Integer.valueOf(x.getPosit()), String.valueOf(protocolEntity.getProtocolType()));
                                                        }
                                                        // DO
                                                        if (StringUtils.isNotEmpty(addCode) && addCode.equals("128")) {

                                                            //
                                                            // parseOrder(x,localDateTime,addCode,pid,Integer.valueOf(x.getPosit()),"129");

                                                        }
                                                        // DI
                                                        if (StringUtils.isNotEmpty(addCode) && addCode.equals("129")) {

                                                            parseOrder(x, localDateTime, addCode, pid, Integer.valueOf(x.getPosit()), "129");
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            log.error("模板解析错误,设备编号为：" + equipId);
                                        }
                                    }

                                } else {
                                    log.error(" 协议唯一编号不存在");
                                }
                            });
        }

        if (msg.getRequestHead().getMsgType().equals(String.valueOf(Constants.MsgType.MsgType_agent.getValue()))) {
            ctx.fireChannelRead(msg);
        }
    }
```

